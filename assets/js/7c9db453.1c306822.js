"use strict";(self.webpackChunkpabpereza=self.webpackChunkpabpereza||[]).push([[5592],{53960:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>c,toc:()=>t});var s=o(17624),r=o(4552);const a={},i=void 0,c={id:"notas/Kubernetes/seguridad",title:"seguridad",description:"La seguridad en Kubernetes es un tema muy amplio. Podemos agruparlo en varias categor\xedas:",source:"@site/docs/notas/Kubernetes/seguridad.md",sourceDirName:"notas/Kubernetes",slug:"/notas/Kubernetes/seguridad",permalink:"/docs/notas/Kubernetes/seguridad",draft:!1,unlisted:!1,editUrl:"https://github.com/pabpereza/pabpereza/tree/main/docs/notas/Kubernetes/seguridad.md",tags:[],version:"current",frontMatter:{},sidebar:"notas",previous:{title:"secrets_configmaps",permalink:"/docs/notas/Kubernetes/secrets_configmaps"},next:{title:"services",permalink:"/docs/notas/Kubernetes/services"}},d={},t=[{value:"Autenticaci\xf3n, autorizaci\xf3n y control de admisi\xf3n",id:"autenticaci\xf3n-autorizaci\xf3n-y-control-de-admisi\xf3n",level:2},{value:"Autenticaci\xf3n",id:"autenticaci\xf3n",level:3},{value:"Autorizaci\xf3n",id:"autorizaci\xf3n",level:3},{value:"RBAC (Role Based Access Control)",id:"rbac-role-based-access-control",level:4},{value:"Controlador de admisi\xf3n (Admission Controller)",id:"controlador-de-admisi\xf3n-admission-controller",level:3},{value:"Security Context",id:"security-context",level:2},{value:"Pod Security Policy",id:"pod-security-policy",level:2},{value:"Network Security Policies",id:"network-security-policies",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.M)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"La seguridad en Kubernetes es un tema muy amplio. Podemos agruparlo en varias categor\xedas:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Seguridad de accesos e identidades (Autenticaci\xf3n y Autorizaci\xf3n)"}),"\n",(0,s.jsx)(n.li,{children:"Contexto de seguridad (Security Context)"}),"\n",(0,s.jsx)(n.li,{children:"Pol\xedticas de seguridad para Pods (Pod Security Policy)"}),"\n",(0,s.jsx)(n.li,{children:"Pol\xedticas de red (Network Security Policies)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"autenticaci\xf3n-autorizaci\xf3n-y-control-de-admisi\xf3n",children:"Autenticaci\xf3n, autorizaci\xf3n y control de admisi\xf3n"}),"\n",(0,s.jsx)(n.p,{children:"Cada llamada que hacemos al API de kubernetes es autenticada y autorizada. Adem\xe1s, podemos configurar un control de admisi\xf3n para rechazar llamadas que no cumplan ciertas condiciones."}),"\n",(0,s.jsxs)(n.p,{children:["Este diagrama ilustra este proceso:\n",(0,s.jsx)(n.img,{src:"https://kubernetes.io/images/docs/admin/access-control-overview.svg",alt:"Diagrama de autenticaci\xf3n, autorizaci\xf3n y control de admisi\xf3n"})]}),"\n",(0,s.jsx)(n.h3,{id:"autenticaci\xf3n",children:"Autenticaci\xf3n"}),"\n",(0,s.jsx)(n.p,{children:"La autenticaci\xf3n es el proceso de identificaci\xf3n de un usuario. Kubernetes soporta varios m\xe9todos de autenticaci\xf3n. Por ejemplo, podemos usar certificados, tokens, contrase\xf1as, etc."}),"\n",(0,s.jsx)(n.h3,{id:"autorizaci\xf3n",children:"Autorizaci\xf3n"}),"\n",(0,s.jsx)(n.p,{children:"La autorizaci\xf3n es el proceso de determinar si un usuario tiene permisos para realizar una acci\xf3n. Kubernetes soporta varios m\xe9todos de autorizaci\xf3n. Por ejemplo, podemos usar roles y permisos, pol\xedticas de RBAC, etc."}),"\n",(0,s.jsx)(n.p,{children:"Para esta secci\xf3n, consulta la documentaci\xf3n sobre [[usuarios_roles]]"}),"\n",(0,s.jsx)(n.h4,{id:"rbac-role-based-access-control",children:"RBAC (Role Based Access Control)"}),"\n",(0,s.jsxs)(n.p,{children:["RBAC es un m\xe9todo de autorizaci\xf3n basado en roles. En este m\xe9todo, definimos roles y permisos. Luego, asignamos los roles a los usuarios. Por ejemplo, podemos definir un rol ",(0,s.jsx)(n.code,{children:"admin"})," con permisos de lectura y escritura. Luego, podemos asignar este rol a un usuario ",(0,s.jsx)(n.code,{children:"admin"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Para conseguir esta granularidad, se definen operaciones CRUD (Create, Read, Update, Delete) sobre recursos. Por ejemplo, podemos definir permisos para crear, leer, actualizar y borrar pods. Luego, podemos asignar estos permisos a un rol. Por ejemplo, podemos definir un rol ",(0,s.jsx)(n.code,{children:"admin"})," con permisos para crear, leer, actualizar y borrar pods. Luego, podemos asignar este rol a un usuario ",(0,s.jsx)(n.code,{children:"admin"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Esto nos permite definir roles con permisos muy espec\xedficos. Por ejemplo, podemos definir un rol ",(0,s.jsx)(n.code,{children:"pod-reader"})," con permisos para leer pods. Luego, podemos asignar este rol a un usuario ",(0,s.jsx)(n.code,{children:"reader"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"controlador-de-admisi\xf3n-admission-controller",children:"Controlador de admisi\xf3n (Admission Controller)"}),"\n",(0,s.jsx)(n.p,{children:"El controlador de admisi\xf3n es un componente que se ejecuta antes de que se realice una acci\xf3n en el API de kubernetes. Podemos configurar varios controladores de admisi\xf3n."}),"\n",(0,s.jsxs)(n.p,{children:["Podemos ver las configuraciones de los controladores de admisi\xf3n en el fichero ",(0,s.jsx)(n.code,{children:"/etc/kubernetes/manifests/kube-apiserver.yaml"})," en el nodo maestro. Por ejemplo:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo grep admission /etc/kubernetes/manifests/kube-apiserver.yaml\n"})}),"\n",(0,s.jsx)(n.h2,{id:"security-context",children:"Security Context"}),"\n",(0,s.jsx)(n.p,{children:"Los pods y contenedores en kubernetes pueden ejecutarse con un contexto de seguridad. Este contexto de seguridad define los permisos que tiene el contenedor, sus capacidades y limitaciones, etc."}),"\n",(0,s.jsxs)(n.p,{children:["Por ejemplo, podemos configurar un contexto de seguridad para que un contenedor no pueda ejecutar comandos como ",(0,s.jsx)(n.code,{children:"sudo"})," o ",(0,s.jsx)(n.code,{children:"su"}),". Tambi\xe9n podemos configurar un contexto de seguridad para que un contenedor no pueda ejecutar comandos como ",(0,s.jsx)(n.code,{children:"mount"})," o ",(0,s.jsx)(n.code,{children:"umount"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Estos contextos se definen dentro de los ",(0,s.jsx)(n.code,{children:"spec"})," de los pods. Por ejemplo, podemos definir un contexto de seguridad para un pod de la siguiente forma:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\nspec:\n  securityContext:\n\trunAsUser: 1000\n\trunAsGroup: 3000\n\tfsGroup: 2000\n  containers:\n  - name: nginx\n\timage: nginx\n\tports:\n\t- containerPort: 80\n"})}),"\n",(0,s.jsx)(n.p,{children:"Si una de las propiedades del contexto de seguridad se incumple, el contenedor no se ejecutar\xe1. Se quedar\xe1 en un estado de error y en su mensaje de estado se mostrar\xe1 el motivo del error."}),"\n",(0,s.jsx)(n.h2,{id:"pod-security-policy",children:"Pod Security Policy"}),"\n",(0,s.jsxs)(n.p,{children:["DEPRECADO: Pod Security Policy est\xe1 deprecado en Kubernetes 1.21 y se eliminar\xe1 en Kubernetes 1.25. En su lugar, se recomienda usar ",(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/security/pod-security-admission/",children:"Admission Controller de Pod Security"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Las Pod Security Policies (PSP) sos permiten definir pol\xedticas de seguridad para todos los pods, a diferencia de la aproximaci\xf3n anterior, la cu\xe1l requeria definir el contexto de seguridad en cada pod."}),"\n",(0,s.jsxs)(n.p,{children:["Podemos definir una PSP para que los pods no puedan ejecutar comandos como ",(0,s.jsx)(n.code,{children:"sudo"})," o ",(0,s.jsx)(n.code,{children:"su"}),", no puedan ejecutar ciertos comandos, sean incapaz de montar vol\xfamenes, etc."]}),"\n",(0,s.jsx)(n.h2,{id:"network-security-policies",children:"Network Security Policies"}),"\n",(0,s.jsx)(n.p,{children:"Por defecto, los pods en kubernetes pueden comunicarse con cualquier otro pod y todo tipo de tr\xe1fico es permitido. Podemos configurar pol\xedticas de red para restringir este tr\xe1fico."}),"\n",(0,s.jsx)(n.p,{children:"Cuando aplicamos una pol\xedtica, por defecto, se restringe todo el tr\xe1fico de entrada y salida. Luego debemos configurar manualmente las excepciones."}),"\n",(0,s.jsxs)(n.p,{children:["Por ejemplo, podemos configurar una pol\xedtica de red para que un pod solo pueda comunicarse con otros pods que tengan un label ",(0,s.jsx)(n.code,{children:"app=nginx"}),". Tambi\xe9n podemos configurar una pol\xedtica de red para que un pod solo pueda comunicarse con otros pods que tengan un label ",(0,s.jsx)(n.code,{children:"app=nginx"})," y que est\xe9n en el mismo namespace."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: ingress-egress-policy\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      role: db\n  policyTypes:\n    - Ingress\n    - Egress\n  ingress:\n    - from:\n        - ipBlock:\n        cidr: 172.17.0.0/16\n            except:\n              - 172.17.1.0/24\n        - namespaceSelector:\n            matchLabels:\n              project: myproject\n        - podSelector:\n            matchLabels:\n              role: frontend\n      ports:\n        - protocol: TCP\n          port: 6379\n  egress:\n    - to:\n        - ipBlock:\n            cidr: 10.0.0.0/24\n      ports:\n        - protocol: TCP\n          port: 5978\n"})}),"\n",(0,s.jsx)(n.p,{children:"En este ejemplo, restringimos el tr\xe1fico entrante a un rango de IPs (con una excepci\xf3n), en un namespace concreto y en los pods con el label 'frontend'. Tambi\xe9n limitamos este tr\xe1fico a un puerto concreto."}),"\n",(0,s.jsx)(n.p,{children:"Tambi\xe9n restringimos el tr\xe1fico saliente a un rango de IPs y a un puerto concreto."}),"\n",(0,s.jsxs)(n.p,{children:["Podemos usar ",(0,s.jsx)(n.code,{children:"{}"})," para seleccionar todos los pods y no permitir ning\xfan tr\xe1fico. Por ejemplo, para todo el tr\xe1fico de entrada:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: ingress-egress-policy\n  namespace: default\nspec:\n  podSelector: {}\n  policyTypes:\n\t- Ingress\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Si no especificamos el tr\xe1fico de salida ",(0,s.jsx)(n.code,{children:"egress"}),", no se ver\xe1 afectado por esta pol\xedtica."]})]})}function u(e={}){const{wrapper:n}={...(0,r.M)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},4552:(e,n,o)=>{o.d(n,{I:()=>c,M:()=>i});var s=o(11504);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);